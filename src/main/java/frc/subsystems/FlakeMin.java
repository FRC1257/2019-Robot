package frc.subsystems;

import frc.robot.*;

import com.revrobotics.*;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * <h1>FlakeMin</h1>
 * This allows us to perform closed-loop drivetrain as well as other fun things.
 * @author Allen Du
 * @since 2019-01-21
 */
public class FlakeMin extends CANSparkMax {

    private CANPIDController pid;
    private CANEncoder encoder;

    private double currentVelocity;
    private double speed;
    private boolean left;
    private double temp;

    /**
     * Constructs a new {@code FlakeMin} object.
     * @param deviceID The port it's wired to.
     * @param type Brushed or brushless, depending on the motor.
     * @param left If it's on the left side or not.
     */
    public FlakeMin(int deviceID, CANSparkMaxLowLevel.MotorType type, boolean left) {
        super(deviceID, type);
        updatePID(left);

        pid = getPIDController();
        encoder = getEncoder();
        
        currentVelocity = 0.0;
        this.left = left;
    }

    /**
     * Runs PID to set the motor at a constant speed; closed-loop velocity.
     * @param speed The desired speed.
     */
    @Override
    public void set(double speed) {
        currentVelocity = updateInput(currentVelocity, speed); // Apply the washout filter
        pid.setReference(RobotMap.NEO_MAX_RPM * currentVelocity, ControlType.kVelocity);
    }

    /**
     * Used for a washout filter. It takes an input and runs a P loop on it.
     * @param currentInput The actual, empirical input.
     * @param targetInput The desired input.
     * @return The output generated by the P loop.
     */
    private double updateInput(double currentInput, double targetInput) {
        double error = targetInput - currentInput;
        currentInput += RobotMap.DRIVE_P_WASHOUT * error;
        return currentInput;
    }

    /**
     * Updates the PID constants from RobotMap
     * @param left If it's on the left side or not
     */
    public void updatePID(boolean left) {
        if(left) pidSetup(RobotMap.DRIVE_PIDF_LEFT);
        else pidSetup(RobotMap.DRIVE_PIDF_RIGHT);
    }

    /**
     * Sets the controller's PID more efficiently than the default functions. Also sets up the maximum output
     * @param pidf Array of doubles with the proportional, integral, derivative, and feedforward terms
     */
    public void pidSetup(double[] pidf) {
        pid.setP(pidf[0]);
        pid.setI(pidf[1]);
        pid.setD(pidf[2]);
        pid.setFF(pidf[3]);

        pid.setOutputRange(-1.0, 1.0);
    }

    /**
     * Gets the speed of the motor, in RPM, using an encoder.
     * @return The speed in RPM.
     */
    public double getEncoderVelocity() {
        speed = encoder.getVelocity();
        return speed;
    }

    /**
     * Gets the distance, in total revolutions, traveled by the motor using an encoder.
     * @return The distance in accumulated rotations.
     */
    public double getEncoderPosition() {
        return encoder.getPosition() - temp;
    }
    
    /**
     * Gets the distance traveled in inches.
     * @return The distance in inches.
     */
    public double getEncoderPositionInches() {
        return getEncoderPosition() * RobotMap.DRIVE_WHEEL_DIAMETER * RobotMap.PI;
    }

    /**
     * Gets the distance traveled in feet.
     * @return The distance in feet.
     */
    public double getEncoderPositionFeet() {
        return getEncoderPositionInches() / 12.0;
    }

    /**
     * Gets the speed in inches.
     * @return The speed in inches.
     */
    public double getEncoderVelocityInches() {
        return getEncoderVelocity() * RobotMap.DRIVE_WHEEL_DIAMETER * RobotMap.PI;
    }

    /**
     * Gets the speed in feet.
     * @return The speed in feet.
     */
    public double getEncoderVelocityFeet() {
        return getEncoderVelocityInches() / 12.0;
    }

    /**
     * Resets the speed.
     */
    public void resetVelocity() {
        speed = 0.0;
    }
    
    /**
     * Resets the total distance traveled.
     */
    public void resetEncoderPosition() {
        temp = encoder.getPosition();
    }
    
    /**
     * Resets the speed and distance.
     */
    public void resetAll() {
        resetVelocity();
        resetEncoderPosition();
    }

    public double getVoltage() {
        return getBusVoltage() * getAppliedOutput(); 
    }
    
    /**
     * Prints speed and distance info.
     */
    public void outputValues() {
        String prefix = left ? "Left " : "Right ";
        SmartDashboard.putNumber(prefix + "Position", getEncoderPosition());
        SmartDashboard.putNumber(prefix + "Position Inches", getEncoderPositionInches());
        SmartDashboard.putNumber(prefix + "Velocity", getEncoderVelocity());
        SmartDashboard.putNumber(prefix + "Velocity Inches", getEncoderVelocityInches());
        SmartDashboard.putNumber(prefix + "Voltage", getVoltage());
    }
}