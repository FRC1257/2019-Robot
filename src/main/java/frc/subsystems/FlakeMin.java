package frc.subsystems;

import frc.robot.*;

import com.revrobotics.*;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * <h1>FlakeMin</h1>
 * This allows us to perform closed-loop drivetrain as well as other fun things.
 * @author Allen Du, Arthur Chen, Om Desai, and Nicole Giron
 * @since 2019-01-21
 */
public class FlakeMin extends CANSparkMax {

    private CANPIDController PID;
    private CANEncoder encoder;

    private double currentVelocity;
    private double Speed;
    private double distance;
    private double temp;

    /**
     * Constructs a new {@code FlakeMin} object.
     * @param deviceID The port it's wired to.
     * @param type Brushed or brushless, depending on the motor.
     * @param left If it's on the left side or not.
     */
    public FlakeMin(int deviceID, CANSparkMaxLowLevel.MotorType type, boolean left) {
        super(deviceID, type);
        getPID();
        if(left) {
            PIDSetup(RobotMap.DRIVE_PID_LEFT_P, RobotMap.DRIVE_PID_LEFT_I, 
                RobotMap.DRIVE_PID_LEFT_D, RobotMap.DRIVE_PID_LEFT_F);
        } else {
            PIDSetup(RobotMap.DRIVE_PID_RIGHT_P, RobotMap.DRIVE_PID_RIGHT_I, 
                RobotMap.DRIVE_PID_RIGHT_D, RobotMap.DRIVE_PID_RIGHT_F);
        }
        
        currentVelocity = 0.0;
        encoder = getEncoder();
    }

    /**
     * Used for a washout filter. It takes an input and runs a P loop on it.
     * @param currentInput The actual, empirical input.
     * @param targetInput The desired input.
     * @return The output generated by the P loop.
     */
    private double updateInput(double currentInput, double targetInput) {
        double error = targetInput - currentInput;
        currentInput += RobotMap.DRIVE_P_WASHOUT * error;
        return currentInput;
    }

    @Override
    /**
     * Runs PID to set the motor at a constant speed; closed-loop velocity.
     * @param speed The desired speed.
     */
    public void set(double speed) {
        PID.setReference(RobotMap.NEO_MAX_RPM * updateInput(currentVelocity, speed), ControlType.kVelocity);
        currentVelocity = updateInput(currentVelocity, speed);
    }

    /**
     * Sets the controller's PID more efficiently than the default functions.
     * @param kFF Feedfoward term
     * @param kP Proportional term
     * @param kI Integral term
     * @param kD Differential term
     */
    public void PIDSetup(double kP, double kI, double kD, double kFF) {
        PID.setP(kP);
        PID.setI(kI);
        PID.setD(kD);
        PID.setFF(kFF);

        PID.setOutputRange(0, RobotMap.NEO_MAX_RPM);
    }

    /**
     * Creates the PID object.
     */
    public void getPID() {
        PID = getPIDController();
    }

    /**
     * Gets the speed of the motor, in RPM, using an encoder.
     * @return The speed in RPM.
     */
    public double getEncoderVelocity() {
        Speed = encoder.getVelocity();
        return Speed;
    }

    /**
     * Gets the distance, in total revolutions, traveled by the motor using an encoder.
     * @return The distance in accumulated rotations.
     */
    public double getEncoderPosition() {
        distance = encoder.getPosition();
        return distance - temp;
    }
    
    /**
     * Gets the distance traveled in inches.
     * @return The distance in inches.
     */
    public double getEncoderPositionInches() {
        return getEncoderPosition() * RobotMap.DRIVE_DIAMETER * RobotMap.PI;
    }

    /**
     * Gets the distance traveled in feet.
     * @return The distance in feet.
     */
    public double getEncoderPositionFeet() {
        return getEncoderPositionInches() / 12;
    }

    /**
     * Gets the speed in feet.
     * @return The speed in feet.
     */
    public double getEncoderVelocityFeet() {
        return getEncoderVelocity() * RobotMap.DRIVE_DIAMETER * RobotMap.PI / 12;
    }

    /**
     * Gets the speed in inches.
     * @return The speed in inches.
     */
    public double getEncoderVelocityInches() {
        return getEncoderVelocityFeet() / 12;
    }

    /**
     * Resets the speed.
     */
    public void resetVelocity() {
        Speed = 0.0;
        SmartDashboard.putString(RobotMap.RESET_STATUS, "Encoder speed reset.");
    }

    /**
     * Resets the total distance traveled.
     */
    public void resetEncoderPosition() {
        temp = getEncoderPosition();
        SmartDashboard.putString(RobotMap.RESET_STATUS, "Encoder position reset.");
    }

    /**
     * Resets the speed and distance.
     */
    public void resetAll() {
        resetVelocity();
        resetEncoderPosition();
        SmartDashboard.putString(RobotMap.RESET_STATUS, "Speed and distance reset.");
    }

    public void printSpeed() {
        SmartDashboard.putNumber(RobotMap.CURRENT_SPEED, getEncoderVelocity());
    }

    public void printPlace() {
        SmartDashboard.putNumber(RobotMap.CURRENT_DISTANCE, getEncoderPosition());
    }

    public void printPlaceInches() {
        SmartDashboard.putNumber(RobotMap.CURRENT_DISTANCE_INCHES, getEncoderPositionInches());
    }

    public void printPlaceFeet() {
        SmartDashboard.putNumber(RobotMap.CURRENT_DISTANCE_FEET, getEncoderPositionFeet());
    }

    public void printSpeedInches() {
        SmartDashboard.putNumber(RobotMap.CURRENT_SPEED_INCHES, getEncoderVelocityInches());
    }

    public void printSpeedFeet() {
        SmartDashboard.putNumber(RobotMap.CURRENT_SPEED_FEET, getEncoderVelocityFeet());
    }

    /**
     * Prints speed and distance info.
     */
    public void outputValues() {
        printSpeed();
        printSpeedInches();
        printSpeedFeet();
        printPlace();
        printPlaceInches();
        printPlaceFeet();
    }
}