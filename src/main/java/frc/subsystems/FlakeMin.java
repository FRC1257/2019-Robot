package frc.subsystems;

import frc.robot.*;

import com.revrobotics.*;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * <h1>FlakeMin</h1>
 * This allows us to perform closed-loop drivetrain as well as other fun things.
 * @author Allen Du, Arthur Chen, Om Desai, and Nicole Giron
 * @since 2019-01-21
 */
public class FlakeMin extends CANSparkMax {

    public CANPIDController PID;
    public CANEncoder Encoder;

    private double currentVelocity;
    private double Speed;
    private double Distance;
    private double temp;

    public String resetStatus = "EncoderReset: ";
    public String currentDistance = "Distance traveled: ";
    public String currentSpeed = "Current speed: ";

    /**
     * Constructs a new {@code FlakeMin} object.
     * @param deviceID The port it's wired to.
     * @param type Brushed or brushless, depending on the motor.
     * @param left If it's on the left side or not.
     */
    public FlakeMin(int deviceID, CANSparkMaxLowLevel.MotorType type, boolean left) {
        super(deviceID, type);
        getPID();
        if(left) {
            yourPIDfunctionsucks(RobotMap.DRIVE_PID_LEFT[0], RobotMap.DRIVE_PID_LEFT[1], 
                RobotMap.DRIVE_PID_LEFT[2], RobotMap.DRIVE_PID_LEFT[3]);
        } else {
            yourPIDfunctionsucks(RobotMap.DRIVE_PID_RIGHT[0], RobotMap.DRIVE_PID_RIGHT[1], 
                RobotMap.DRIVE_PID_RIGHT[2], RobotMap.DRIVE_PID_RIGHT[3]);
        }
        currentVelocity = 0.0;
        Encoder = getEncoder();
    }

    /**
     * Used for a washout filter. It takes an input and runs a P loop on it.
     * @param currentInput The actual, empirical input.
     * @param targetInput The desired input.
     * @return The output generated by the P loop.
     */
    private double updateInput(double currentInput, double targetInput) {
        double error;
        error = targetInput - currentInput;
        currentInput += RobotMap.DRIVE_P_WASHOUT * error;
        return currentInput;
    }

    @Override
    /**
     * Runs PID to set the motor at a constant speed; closed-loop velocity.
     * @param speed The desired speed.
     */
    public void set(double speed) {
        PID.setReference(RobotMap.DRIVE_NEO_CONSTS[2] * updateInput(currentVelocity, speed), ControlType.kVelocity);
        currentVelocity = updateInput(currentVelocity, speed);
    }

    /**
     * Sets the controller's PID more efficiently than the default functions.
     * @param kFF Feedfoward term
     * @param kP Proportional term
     * @param kI Integral term
     * @param kD Differential term
     */
    public void yourPIDfunctionsucks(double kFF, double kP, double kI, double kD) {
        PID.setFF(kFF);
        PID.setP(kP);
        PID.setI(kI);
        PID.setD(kD);
    }

    /**
     * Creates the PID object.
     */
    public void getPID() {
        PID = getPIDController();
    }

    /**
     * Gets the speed of the motor, in RPM, using an encoder.
     * @return The speed in RPM.
     */
    public double getSpeed() {
        Speed = Encoder.getVelocity();
        return Speed;
    }

    /**
     * Gets the distance, in total revolutions, traveled by the motor using an encoder.
     * @return The distance in accumulated rotations.
     */
    public double getPlace() {
        Distance = Encoder.getPosition();
        return Distance - temp;
    }
    
    /**
     * Gets the distance traveled in inches.
     * @return The distance in inches.
     */
    public double getPlaceInches() {
        return getPlace() * RobotMap.DRIVE_DIAMETER * RobotMap.PI;
    }

    /**
     * Gets the distance traveled in feet.
     * @return The distance in feet.
     */
    public double getPlaceFeet() {
        return getPlaceInches() / 12;
    }

    /**
     * Gets the speed in feet.
     * @return The speed in feet.
     */
    public double getSpeedFeet() {
        return getSpeed() * RobotMap.DRIVE_DIAMETER * RobotMap.PI / 12;
    }

    /**
     * Gets the speed in inches.
     * @return The speed in inches.
     */
    public double getSpeedInches() {
        return getSpeedFeet() / 12;
    }

    /**
     * Resets the speed.
     */
    public void resetVelocity() {
        Speed = 0.0;
    }

    /**
     * Resets the total distance traveled.
     */
    public void resetPlace() {
        temp = getPlace();
    }

    /**
     * Resets the speed and distance.
     */
    public void resetAll() {
        resetVelocity();
        resetPlace();
        SmartDashboard.putString(resetStatus, "Speed and distance reset.");
    }

    public void printSpeed() {
        SmartDashboard.putString(currentSpeed, getSpeed() + " rotations per minute.");
    }

    public void printPlace() {
        SmartDashboard.putString(currentDistance, getPlace() + " rotations.");
    }

    public void printPlaceInches() {
        SmartDashboard.putString(currentDistance, getPlaceInches() + " inches.");
    }

    public void printPlaceFeet() {
        SmartDashboard.putString(currentDistance, getPlaceFeet() + " feet.");
    }

    public void printSpeedInches() {
        SmartDashboard.putString(currentSpeed, getSpeedInches() + " inches per minute.");
    }

    public void printSpeedFeet() {
        SmartDashboard.putString(currentSpeed, getSpeedFeet() + " feet per minute.");
    }

    /**
     * Prints speed and distance info.
     */
    public void printAll() {
        printSpeed();
        printSpeedInches();
        printSpeedFeet();
        printPlace();
        printPlaceInches();
        printPlaceFeet();
    }
}